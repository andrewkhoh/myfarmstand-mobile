/**
 * PredictiveAnalyticsService Test - Following Service Test Pattern (REFERENCE)
 */

import { createUser, resetAllFactories } from '../../../test/factories';

// Setup all mocks BEFORE any imports
jest.mock("../../../config/supabase", () => {
  const { SimplifiedSupabaseMock } = require("../../../test/mocks/supabase.simplified.mock");
  const mockInstance = new SimplifiedSupabaseMock();
  return {
    supabase: mockInstance.createClient(),
    TABLES: {
      USERS: 'users',
      PRODUCTS: 'products',
      ORDERS: 'orders',
      PREDICTIVE_FORECASTS: 'predictive_forecasts',
      ANALYTICS_MODELS: 'analytics_models',
      REPORTS: 'reports'
    }
  };
});

// Mock ValidationMonitor
jest.mock('../../../utils/validationMonitor', () => ({
  ValidationMonitor: {
    recordValidationError: jest.fn(),
    recordPatternSuccess: jest.fn(),
  }
}));

// Mock role permissions service
jest.mock('../../rolePermissionService', () => ({
  RolePermissionService: {
    hasPermission: jest.fn().mockResolvedValue(true),
    getUserRole: jest.fn().mockResolvedValue('admin'),
    checkRoleAccess: jest.fn().mockResolvedValue(true),
  }
}));

// Mock business metrics service for integration tests
jest.mock('../businessMetricsService', () => ({
  BusinessMetricsService: {
    getMetricsByCategory: jest.fn().mockResolvedValue([
      { metricName: 'inventory_turnover', metricValue: 2.5, metricDate: '2024-01-01' }
    ]),
  }
}));

// Import AFTER mocks are setup
import { PredictiveAnalyticsService } from '../predictiveAnalyticsService';
import { supabase } from '../../../config/supabase';
import { ValidationMonitor } from '../../../utils/validationMonitor';
import { RolePermissionService } from '../../rolePermissionService';
import { BusinessMetricsService } from '../businessMetricsService';

// Get mock references for use in tests
const mockSupabaseFrom = supabase.from as jest.Mock;

describe('PredictiveAnalyticsService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup default mocks for successful operations
    (ValidationMonitor.recordPatternSuccess as jest.Mock).mockResolvedValue(undefined);
    (ValidationMonitor.recordValidationError as jest.Mock).mockResolvedValue(undefined);
  });

  describe('generateForecast', () => {
    it('should generate forecast with seasonal model', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'forecast-1',
            forecast_type: 'demand',
            forecast_target: 'inventory_turnover',
            model_accuracy: 0.91,
            generated_at: new Date().toISOString()
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.generateForecast(
        'demand',
        'inventory_turnover',
        '2024-02-01',
        '2024-02-29',
        {
          model_type: 'seasonal_decomposition',
          include_seasonality: true,
          confidence_level: 0.95
        }
      );

      expect(result).toBeDefined();
      expect(result.forecastData).toBeDefined();
      expect(result.modelAccuracy).toBeGreaterThan(0);
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should generate ensemble forecast', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'forecast-2',
            forecast_type: 'revenue',
            model_accuracy: 0.92,
            generated_at: new Date().toISOString()
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.generateForecast(
        'revenue',
        'monthly_revenue',
        '2024-02-01',
        '2024-02-29',
        { 
          model_type: 'ensemble',
          ensemble_methods: ['linear_regression', 'seasonal_decomposition', 'arima']
        }
      );

      expect(result).toBeDefined();
      expect(result.forecastData).toBeDefined();
      expect(result.modelAccuracy).toBe(0.92);
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should integrate with historical data', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'forecast-3',
            forecast_type: 'inventory',
            model_accuracy: 0.89,
            generated_at: new Date().toISOString()
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.generateForecast(
        'inventory',
        'inventory_optimization',
        '2024-02-01',
        '2024-02-29',
        { 
          integrate_historical_data: true,
          historical_period_days: 365
        }
      );

      expect(result).toBeDefined();
      expect(result.forecastData).toBeDefined();
      expect(result.modelAccuracy).toBe(0.89);
      expect(BusinessMetricsService.getMetricsByCategory).toHaveBeenCalled();
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should handle database errors', async () => {
      // Setup mock database error
      mockSupabaseFrom.mockReturnValue({
        insert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: null,
          error: { message: 'Database connection failed' }
        })
      });

      await expect(
        PredictiveAnalyticsService.generateForecast('demand', 'inventory', '2024-02-01', '2024-02-29')
      ).rejects.toThrow('Failed to save forecast: Database connection failed');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });
  });

  describe('validateModelAccuracy', () => {
    it('should validate model accuracy with cross validation', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'accuracy-test-1',
            model_accuracy: 0.87,
            forecast_values: { predictions: [] }
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.validateModelAccuracy(
        'accuracy-test-1',
        {
          validation_method: 'cross_validation',
          test_data_percentage: 0.2,
          include_statistical_tests: true
        }
      );

      expect(result).toBeDefined();
      expect(result.accuracy).toBeGreaterThan(0);
      expect(result.crossValidation).toBeDefined();
      expect(result.isStatisticallySignificant).toBe(true);
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should detect model overfitting', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'overfitting-test-1',
            model_accuracy: 0.87,
            forecast_values: { predictions: [] }
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.validateModelAccuracy(
        'overfitting-test-1',
        { detect_overfitting: true }
      );

      expect(result).toBeDefined();
      expect(typeof result.overfittingDetected).toBe('boolean');
      expect(result.accuracyGap).toBeDefined();
      expect(Array.isArray(result.recommendations)).toBe(true);
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should enable continuous monitoring', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'monitoring-test-1',
            model_accuracy: 0.89,
            forecast_values: { predictions: [] }
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.validateModelAccuracy(
        'monitoring-test-1',
        { 
          enable_continuous_monitoring: true,
          accuracy_threshold: 0.8,
          monitoring_frequency: 'daily'
        }
      );

      expect(result).toBeDefined();
      expect(result.accuracyTracking).toBeDefined();
      expect(result.accuracyTracking.improvementTrend).toBe('increasing');
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should handle database errors gracefully', async () => {
      // Setup mock database error
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: null,
          error: { message: 'Forecast not found' }
        })
      });

      await expect(
        PredictiveAnalyticsService.validateModelAccuracy('invalid-id')
      ).rejects.toThrow('Failed to get forecast for validation: Forecast not found');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });
  });

  describe('updateForecastData', () => {
    it('should update forecast with model retraining', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'update-forecast-1',
            model_accuracy: 0.91,
            generated_at: new Date().toISOString()
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.updateForecastData(
        'update-forecast-1',
        {
          retrain_model: true,
          add_features: ['market_trends', 'economic_indicators'],
          update_period: '2024-01-15,2024-02-15'
        }
      );

      expect(result).toBeDefined();
      expect(result.modelAccuracy).toBeGreaterThan(0);
      expect(result.forecastValues).toBeDefined();
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should handle incremental updates', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'incremental-1',
            model_accuracy: 0.87,
            generated_at: new Date().toISOString()
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.updateForecastData(
        'incremental-1',
        { 
          update_type: 'incremental',
          new_data_points: 150,
          preserve_model_state: true
        }
      );

      expect(result).toBeDefined();
      expect(result.forecastValues).toBeDefined();
      expect(result.forecastValues.incrementalUpdates).toBeDefined();
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should handle database update errors', async () => {
      // Setup mock database error
      mockSupabaseFrom.mockReturnValue({
        update: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: null,
          error: { message: 'Update failed' }
        })
      });

      await expect(
        PredictiveAnalyticsService.updateForecastData('invalid-id', { retrain_model: true })
      ).rejects.toThrow('Failed to update forecast: Update failed');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });
  });

  describe('getForecastByType', () => {
    it('should get forecasts with role-based access', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        gte: jest.fn().mockReturnThis(),
        order: jest.fn().mockResolvedValue({
          data: [
            {
              id: 'forecast-1',
              forecast_type: 'demand',
              model_accuracy: 0.87,
              generated_at: new Date().toISOString()
            }
          ],
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.getForecastByType(
        'demand',
        { 
          user_role: 'admin',
          active_only: true,
          sort_by: 'accuracy'
        }
      );

      expect(result).toBeDefined();
      expect(Array.isArray(result)).toBe(true);
      expect(RolePermissionService.hasPermission).toHaveBeenCalledWith('admin', 'predictive_analytics_read');
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should enforce role-based access restrictions', async () => {
      // Mock permission denied
      (RolePermissionService.hasPermission as jest.Mock).mockResolvedValueOnce(false);

      await expect(
        PredictiveAnalyticsService.getForecastByType(
          'revenue',
          { user_role: 'staff', user_id: 'user-123' }
        )
      ).rejects.toThrow('Insufficient permissions for revenue forecasting access');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });

    it('should handle database query errors', async () => {
      // Setup mock database error
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        gte: jest.fn().mockReturnThis(),
        order: jest.fn().mockResolvedValue({
          data: null,
          error: { message: 'Query failed' }
        })
      });

      await expect(
        PredictiveAnalyticsService.getForecastByType('demand')
      ).rejects.toThrow('Failed to get forecasts by type: Query failed');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });
  });

  describe('calculateConfidenceIntervals', () => {
    it('should calculate single confidence interval', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'confidence-1',
            model_accuracy: 0.87,
            forecast_values: { predictions: [] }
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.calculateConfidenceIntervals(
        'confidence-1',
        {
          confidence_level: 0.95,
          method: 'bootstrap',
          iterations: 1000
        }
      );

      expect(result).toBeDefined();
      expect(result.confidenceLevel).toBeGreaterThan(0);
      expect(result.upperBound).toBeDefined();
      expect(result.lowerBound).toBeDefined();
      expect(result.statisticalMethod).toBe('bootstrap');
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should calculate multiple confidence levels', async () => {
      // Setup mock database response
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: {
            id: 'multi-confidence-1',
            model_accuracy: 0.87,
            forecast_values: { predictions: [] }
          },
          error: null
        })
      });

      const result = await PredictiveAnalyticsService.calculateConfidenceIntervals(
        'multi-confidence-1',
        { confidence_levels: [0.8, 0.9, 0.95, 0.99] }
      );

      expect(result).toBeDefined();
      expect(result.confidence80).toBeDefined();
      expect(result.confidence90).toBeDefined();
      expect(result.confidence95).toBeDefined();
      expect(result.confidence99).toBeDefined();
      expect(ValidationMonitor.recordPatternSuccess).toHaveBeenCalled();
    });

    it('should handle database errors', async () => {
      // Setup mock database error
      mockSupabaseFrom.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        single: jest.fn().mockResolvedValue({
          data: null,
          error: { message: 'Forecast not found' }
        })
      });

      await expect(
        PredictiveAnalyticsService.calculateConfidenceIntervals('invalid-id')
      ).rejects.toThrow('Failed to get forecast for confidence interval calculation: Forecast not found');

      expect(ValidationMonitor.recordValidationError).toHaveBeenCalled();
    });
  });

  describe('monitorModelPerformance', () => {
    it('should monitor model performance', async () => {
      const result = await PredictiveAnalyticsService.monitorModelPerformance('model-1');

      expect(result).toBeDefined();
      expect(result.modelHealth).toBe('healthy');
      expect(result.performanceMetrics).toBeDefined();
      expect(result.lastChecked).toBeDefined();
    });
  });

  describe('compareModels', () => {
    it('should compare multiple model versions', async () => {
      const result = await PredictiveAnalyticsService.compareModels();

      expect(result).toBeDefined();
      expect(Array.isArray(result.models)).toBe(true);
      expect(result.bestModel).toBeDefined();
      expect(result.improvement).toBeGreaterThan(0);
    });
  });
});