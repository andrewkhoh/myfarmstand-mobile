import { supabase } from '../config/supabase';
import type { EntityType } from './queryKeyFactory';
import CryptoJS from 'crypto-js';
import Constants from 'expo-constants';

// CRYPTOGRAPHIC SECURITY: Enhanced Channel Security with Hash-Based Names
export type BroadcastTarget = 'user-specific' | 'admin-only' | 'global';

interface BroadcastConfig {
  entity: EntityType;
  target: BroadcastTarget;
}

interface BroadcastPayload {
  userId?: string;
  [key: string]: any;
}

// Enhanced broadcast result with security metadata
interface BroadcastResult {
  success: boolean;
  result?: any;
  channelName?: string;
  error?: any;
  fallbackUsed?: boolean;
  fallbackReason?: string;
}

// SECURITY: Cryptographic channel name generation
class SecureChannelNameGenerator {
  private static readonly CHANNEL_SECRET = (() => {
    // SECURITY: Load from Expo Constants (loaded from .env.secret via app.config.js)
    // This ensures cryptographic keys are available in both development and production
    const secret = Constants.expoConfig?.extra?.channelSecret || process.env.EXPO_PUBLIC_CHANNEL_SECRET;
    
    if (!secret) {
      throw new Error(
        'üö® SECURITY ERROR: EXPO_PUBLIC_CHANNEL_SECRET environment variable is required for cryptographic channel security.\n\n' +
        'SETUP INSTRUCTIONS:\n' +
        '1. Create a .env.secret file in your project root\n' +
        '2. Generate a secure key: node -e "console.log(require(\'crypto\').randomBytes(32).toString(\'hex\'))"\n' +
        '3. Add to .env.secret: EXPO_PUBLIC_CHANNEL_SECRET=<your-generated-key>\n' +
        '4. Ensure app.config.js loads .env.secret (should be automatic)\n' +
        '5. Ensure .env.secret is in .gitignore (never commit secrets!)\n\n' +
        'The .env.secret file should contain:\n' +
        'EXPO_PUBLIC_CHANNEL_SECRET=<your-64-character-hex-key-here>'
      );
    }
    if (secret.length < 32) {
      throw new Error(
        'üö® SECURITY ERROR: EXPO_PUBLIC_CHANNEL_SECRET must be at least 32 characters long for cryptographic security.\n' +
        'Current length: ' + secret.length + '\n' +
        'Generate a new 256-bit key: node -e "console.log(require(\'crypto\').randomBytes(32).toString(\'hex\'))"'
      );
    }
    console.log('üîê Cryptographic channel security enabled with 256-bit key');
    return secret;
  })();
  private static readonly SALT_PREFIX = 'myfarmstand-secure-channel';
  
  /**
   * Generate cryptographically secure channel name
   * Uses HMAC-SHA256 to prevent channel name enumeration attacks
   */
  static generateSecureChannelName(entity: EntityType, target: BroadcastTarget, userId?: string): string {
    const baseData = `${this.SALT_PREFIX}-${entity}-${target}`;
    
    switch (target) {
      case 'user-specific':
        if (!userId) {
          throw new Error('userId required for user-specific secure channel');
        }
        // SECURITY: HMAC-SHA256 hash of user ID + entity + salt
        const userHash = CryptoJS.HmacSHA256(`${baseData}-${userId}`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-${userHash.substring(0, 16)}`; // First 16 chars for readability
        
      case 'admin-only':
        // SECURITY: Admin channels use entity-specific hash
        const adminHash = CryptoJS.HmacSHA256(`${baseData}-admin`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-admin-${adminHash.substring(0, 12)}`;
        
      case 'global':
        // SECURITY: Global channels use entity hash (same for all users)
        const globalHash = CryptoJS.HmacSHA256(`${baseData}-global`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-global-${globalHash.substring(0, 12)}`;
        
      default:
        throw new Error(`Unknown broadcast target: ${target}`);
    }
  }
  
  /**
   * Generate backup/fallback channel name
   */
  static generateBackupChannelName(entity: EntityType, target: BroadcastTarget, userId?: string): string {
    const baseData = `${this.SALT_PREFIX}-${entity}-${target}-backup`;
    
    switch (target) {
      case 'user-specific':
        if (!userId) {
          throw new Error('userId required for user-specific backup channel');
        }
        const userBackupHash = CryptoJS.HmacSHA256(`${baseData}-${userId}`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-bkp-${userBackupHash.substring(0, 16)}`;
        
      case 'admin-only':
        const adminBackupHash = CryptoJS.HmacSHA256(`${baseData}-admin`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-admin-bkp-${adminBackupHash.substring(0, 12)}`;
        
      case 'global':
        const globalBackupHash = CryptoJS.HmacSHA256(`${baseData}-global`, this.CHANNEL_SECRET).toString();
        return `sec-${entity}-global-bkp-${globalBackupHash.substring(0, 12)}`;
        
      default:
        throw new Error(`Unknown broadcast target: ${target}`);
    }
  }
  
  /**
   * Validate that a channel name was generated by our system
   */
  static validateChannelName(channelName: string, entity: EntityType, target: BroadcastTarget, userId?: string): boolean {
    try {
      const expectedChannel = this.generateSecureChannelName(entity, target, userId);
      return channelName === expectedChannel;
    } catch {
      return false;
    }
  }
}

// SECURITY: Sanitize payload to prevent injection and data leakage
const sanitizePayload = (payload: BroadcastPayload, allowedFields: string[]): BroadcastPayload => {
  const sanitized: BroadcastPayload = {};
  
  // Only include explicitly allowed fields
  for (const field of allowedFields) {
    if (payload[field] !== undefined) {
      // Basic sanitization - prevent object injection
      if (typeof payload[field] === 'string' || typeof payload[field] === 'number' || typeof payload[field] === 'boolean') {
        sanitized[field] = payload[field];
      }
    }
  }
  
  return sanitized;
};

// SECURITY: Safe logging that excludes sensitive data
const safeLog = (message: string, data: any, level: 'info' | 'warn' | 'error' = 'info') => {
  // Remove sensitive fields from logs
  const safeCopy = { ...data };
  delete safeCopy.userId;
  delete safeCopy.payload;
  delete safeCopy.personalData;
  delete safeCopy.cartItems;
  delete safeCopy.orderItems;
  
  // SECURITY: Environment-controlled channel name debugging
  // Set DEBUG_CHANNELS=true in .env.secret to verify encryption is working
  const debugChannels = process.env.DEBUG_CHANNELS === 'true';
  
  if (debugChannels && data.channelName) {
    console.log(`üîê DEBUG: Encrypted channel name: ${data.channelName}`);
  }
  
  if (!debugChannels) {
    delete safeCopy.channelName; // SECURITY: Don't log actual channel names in production
  }
  
  const logFn = level === 'error' ? console.error : level === 'warn' ? console.warn : console.log;
  logFn(message, safeCopy); // ‚Üê THIS IS WHERE safeCopy IS USED
};

export const createBroadcastHelper = (config: BroadcastConfig) => {
  const { entity, target } = config;
  
  // SECURITY: Define allowed fields per entity to prevent data leakage
  const getAllowedFields = (entityType: EntityType): string[] => {
    switch (entityType) {
      case 'cart':
        return ['userId', 'productId', 'quantity', 'timestamp', 'action'];
      case 'orders':
        return ['userId', 'orderId', 'status', 'timestamp', 'action'];
      case 'products':
        return ['productId', 'action', 'timestamp']; // No userId for global products
      default:
        return ['timestamp', 'action']; // Minimal safe fields
    }
  };
  
  return {
    send: async (event: string, payload: BroadcastPayload): Promise<BroadcastResult> => {
      try {
        // SECURITY: Validate and sanitize payload
        const allowedFields = getAllowedFields(entity);
        const sanitizedPayload = sanitizePayload(payload, allowedFields);
        
        // CRYPTOGRAPHIC SECURITY: Generate secure channel names
        let channelName: string;
        let fallbackChannelName: string | null = null;
        
        try {
          switch (target) {
            case 'user-specific':
              if (!sanitizedPayload.userId) {
                console.error(`‚ùå ${entity} broadcast missing userId for user-specific channel`);
                return { 
                  success: false, 
                  error: 'Missing userId for user-specific broadcast',
                  fallbackUsed: false
                };
              }
              channelName = SecureChannelNameGenerator.generateSecureChannelName(entity, target, sanitizedPayload.userId);
              // SECURITY FIX: NO fallback to global for user-specific data!
              break;
              
            case 'admin-only':
              channelName = SecureChannelNameGenerator.generateSecureChannelName(entity, target);
              // SECURITY: Admin data only falls back to secure admin backup
              fallbackChannelName = SecureChannelNameGenerator.generateBackupChannelName(entity, target);
              break;
              
            case 'global':
              channelName = SecureChannelNameGenerator.generateSecureChannelName(entity, target);
              fallbackChannelName = SecureChannelNameGenerator.generateBackupChannelName(entity, target);
              break;
          }
        } catch (channelError) {
          console.error(`‚ùå Failed to generate secure channel name for ${entity}:`, channelError);
          return {
            success: false,
            error: 'Failed to generate secure channel name',
            fallbackUsed: false
          };
        }
        
        // Primary broadcast attempt
        try {
          const channel = supabase.channel(channelName);
          const result = await channel.send({
            type: 'broadcast',
            event,
            payload: sanitizedPayload // SECURITY: Only send sanitized data
          });
          
          // SECURITY: Safe logging without sensitive data (no channel names logged)
          safeLog(`üì§ ${entity} secure broadcast sent to ${target} channel: ${event}`, { 
            result, event, success: true, channelName
          });
          
          return { 
            success: true, 
            result, 
            channelName, // Return for internal use, but don't log
            fallbackUsed: false
          };
        } catch (primaryError) {
          // SECURITY: Only attempt fallback for non-user-specific data
          if (target === 'user-specific') {
            console.error(`‚ùå ${entity} user-specific secure broadcast failed - NO FALLBACK for privacy protection:`, primaryError);
            return { 
              success: false, 
              error: primaryError,
              fallbackUsed: false,
              fallbackReason: 'user_data_no_fallback_for_privacy'
            };
          }
          
          if (!fallbackChannelName) {
            return { 
              success: false, 
              error: primaryError,
              fallbackUsed: false
            };
          }
          
          safeLog(`‚ö†Ô∏è Primary ${entity} secure broadcast failed, attempting secure fallback`, { primaryError }, 'warn');
          
          // Fallback Strategy: Only for admin/global data
          try {
            const fallbackChannel = supabase.channel(fallbackChannelName);
            const fallbackResult = await fallbackChannel.send({
              type: 'broadcast',
              event,
              payload: {
                ...sanitizedPayload, // SECURITY: Still use sanitized payload
                _meta: { // SECURITY: Separate metadata from user data
                  originalChannel: 'redacted', // Don't expose channel names
                  fallbackReason: 'primary_channel_failed',
                  timestamp: new Date().toISOString()
                }
              }
            });
            
            safeLog(`üì§ ${entity} secure fallback broadcast sent`, { 
              event, success: true, fallbackUsed: true, channelName: fallbackChannelName
            });
            
            return { 
              success: true, 
              result: fallbackResult, 
              channelName: fallbackChannelName,
              fallbackUsed: true,
              fallbackReason: 'primary_channel_failed'
            };
          } catch (fallbackError) {
            console.error(`‚ùå ${entity} secure fallback broadcast also failed:`, fallbackError);
            
            return { 
              success: false, 
              error: fallbackError,
              fallbackUsed: true,
              fallbackReason: 'all_channels_failed'
            };
          }
        }
      } catch (error) {
        console.error(`‚ùå ${entity} secure broadcast failed completely:`, error);
        return { 
          success: false, 
          error,
          fallbackUsed: false
        };
      }
    },
    
    // CRYPTOGRAPHIC SECURITY: Enhanced channel name generation
    getChannelName: (userId?: string, useFallback: boolean = false) => {
      try {
        if (useFallback) {
          return SecureChannelNameGenerator.generateBackupChannelName(entity, target, userId);
        } else {
          return SecureChannelNameGenerator.generateSecureChannelName(entity, target, userId);
        }
      } catch (error) {
        console.error(`‚ùå Failed to generate secure channel name for ${entity}:`, error);
        throw error;
      }
    },
    
    // CRYPTOGRAPHIC SECURITY: Only return channels user is authorized to access
    getAuthorizedChannelNames: (userId?: string, userRole?: string) => {
      const channels: string[] = [];
      
      try {
        switch (target) {
          case 'user-specific':
            if (userId) {
              channels.push(SecureChannelNameGenerator.generateSecureChannelName(entity, target, userId));
            }
            break;
            
          case 'admin-only':
            // SECURITY: Only admins get admin channels
            if (userRole === 'admin' || userRole === 'staff' || userRole === 'manager') {
              channels.push(SecureChannelNameGenerator.generateSecureChannelName(entity, target));
              channels.push(SecureChannelNameGenerator.generateBackupChannelName(entity, target));
            }
            break;
            
          case 'global':
            channels.push(SecureChannelNameGenerator.generateSecureChannelName(entity, target));
            channels.push(SecureChannelNameGenerator.generateBackupChannelName(entity, target));
            break;
        }
      } catch (error) {
        console.error(`‚ùå Failed to generate authorized channel names for ${entity}:`, error);
        return []; // Return empty array on error for security
      }
      
      return channels;
    },
    
    // CRYPTOGRAPHIC SECURITY: Validate channel name authenticity
    validateChannelName: (channelName: string, userId?: string) => {
      return SecureChannelNameGenerator.validateChannelName(channelName, entity, target, userId);
    }
  };
};

// CRYPTOGRAPHIC SECURITY: Pre-configured secure broadcast helpers
export const cartBroadcast = createBroadcastHelper({ entity: 'cart', target: 'user-specific' });

export const orderBroadcast = {
  user: createBroadcastHelper({ entity: 'orders', target: 'user-specific' }),
  admin: createBroadcastHelper({ entity: 'orders', target: 'admin-only' }),
  global: createBroadcastHelper({ entity: 'orders', target: 'global' })
};

export const productBroadcast = createBroadcastHelper({ entity: 'products', target: 'global' });

// CRYPTOGRAPHIC SECURITY: Enhanced multi-target broadcast with secure channels
export const sendMultiTargetBroadcast = async (
  entity: EntityType,
  event: string,
  payload: BroadcastPayload,
  targets: BroadcastTarget[]
): Promise<BroadcastResult[]> => {
  const results: BroadcastResult[] = [];
  
  for (const target of targets) {
    const helper = createBroadcastHelper({ entity, target });
    const result = await helper.send(event, payload);
    results.push(result);
  }
  
  return results;
};

// CRYPTOGRAPHIC SECURITY: Order broadcast with secure channel protection
export const sendOrderBroadcast = async (event: string, payload: BroadcastPayload): Promise<BroadcastResult[]> => {
  // SECURITY: Only send to user-specific and admin channels, never global for orders
  return sendMultiTargetBroadcast('orders', event, payload, ['user-specific', 'admin-only']);
};

// CRYPTOGRAPHIC SECURITY: Main broadcast factory with all secure broadcast methods
export const broadcastFactory = {
  // Cart broadcasts (user-specific only)
  sendCartBroadcast: async (event: string, payload: BroadcastPayload, userId: string): Promise<BroadcastResult> => {
    return cartBroadcast.send(event, { ...payload, userId });
  },
  
  // Order broadcasts (user-specific and admin)
  sendOrderBroadcast: async (event: string, payload: BroadcastPayload): Promise<BroadcastResult[]> => {
    return sendOrderBroadcast(event, payload);
  },
  
  // Product broadcasts (global)
  sendProductBroadcast: async (event: string, payload: BroadcastPayload): Promise<BroadcastResult> => {
    return productBroadcast.send(event, payload);
  },
  
  // Multi-target broadcasts
  sendMultiTargetBroadcast,
  
  // Helper creation
  createBroadcastHelper,
  
  // Pre-configured helpers
  cartBroadcast,
  orderBroadcast,
  productBroadcast
};
