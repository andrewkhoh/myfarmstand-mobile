import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useInventoryDashboard } from '../useInventoryDashboard';
import { InventoryService } from '../../../services/inventory/inventoryService';
import React from 'react';

jest.mock('../../../services/inventory/inventoryService');
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    from: jest.fn(),
    auth: {
      getUser: jest.fn().mockResolvedValue({ data: { user: { id: 'test-user-id' } } })
    }
  }))
}));

describe('useInventoryDashboard', () => {
  let queryClient: QueryClient;
  let mockInventoryService: jest.Mocked<InventoryService>;

  beforeEach(() => {
    jest.clearAllMocks();
    jest.useRealTimers();
    
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false, gcTime: 0 },
        mutations: { retry: false }
      }
    });

    mockInventoryService = {
      getInventoryItems: jest.fn(),
      getLowStockItems: jest.fn(),
      getRecentMovements: jest.fn(),
      getAlerts: jest.fn(),
      getInventoryItem: jest.fn(),
      updateStock: jest.fn(),
      batchUpdateStock: jest.fn(),
      createInventoryItem: jest.fn(),
      deleteInventoryItem: jest.fn(),
      acknowledgeAlert: jest.fn(),
    } as any;

    (InventoryService as jest.MockedClass<typeof InventoryService>).mockImplementation(
      () => mockInventoryService
    );
  });

  afterEach(() => {
    queryClient.clear();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  it('should fetch dashboard data successfully', async () => {
    const mockItems = [
      { id: '1', name: 'Item 1', currentStock: 100, unitPrice: 10 },
      { id: '2', name: 'Item 2', currentStock: 50, unitPrice: 20 }
    ];
    const mockLowStock = [
      { id: '3', name: 'Low Stock Item', currentStock: 5, minStock: 10 }
    ];
    const mockMovements = [
      { id: 'm1', itemId: '1', type: 'in', quantity: 10, createdAt: new Date() }
    ];
    const mockAlerts = [
      { id: 'a1', itemId: '3', type: 'low_stock', message: 'Low stock alert' }
    ];

    mockInventoryService.getInventoryItems.mockResolvedValue(mockItems as any);
    mockInventoryService.getLowStockItems.mockResolvedValue(mockLowStock as any);
    mockInventoryService.getRecentMovements.mockResolvedValue(mockMovements as any);
    mockInventoryService.getAlerts.mockResolvedValue(mockAlerts as any);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toBeDefined();
    expect(result.current.data?.totalItems).toBe(2);
    expect(result.current.data?.lowStockCount).toBe(1);
    expect(result.current.data?.totalValue).toBe(2000);
    expect(result.current.data?.recentMovements).toHaveLength(1);
    expect(result.current.data?.alerts).toHaveLength(1);
  });

  it('should handle loading state', () => {
    mockInventoryService.getInventoryItems.mockImplementation(
      () => new Promise(() => {})
    );

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toBeUndefined();
  });

  it('should handle error state', async () => {
    const mockError = new Error('Failed to fetch dashboard data');
    mockInventoryService.getInventoryItems.mockRejectedValue(mockError);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });

    expect(result.current.error).toBeDefined();
  });

  it('should calculate out of stock count correctly', async () => {
    const mockItems = [
      { id: '1', name: 'Item 1', currentStock: 0, unitPrice: 10 },
      { id: '2', name: 'Item 2', currentStock: 0, unitPrice: 20 },
      { id: '3', name: 'Item 3', currentStock: 100, unitPrice: 15 }
    ];

    mockInventoryService.getInventoryItems.mockResolvedValue(mockItems as any);
    mockInventoryService.getLowStockItems.mockResolvedValue([]);
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data?.outOfStockCount).toBe(2);
  });

  it('should use correct query key', async () => {
    mockInventoryService.getInventoryItems.mockResolvedValue([]);
    mockInventoryService.getLowStockItems.mockResolvedValue([]);
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      const queries = queryClient.getQueryCache().getAll();
      const dashboardQuery = queries.find(q => 
        JSON.stringify(q.queryKey).includes('dashboard')
      );
      expect(dashboardQuery).toBeDefined();
    });
  });

  it('should refetch data on invalidation', async () => {
    mockInventoryService.getInventoryItems.mockResolvedValue([]);
    mockInventoryService.getLowStockItems.mockResolvedValue([]);
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    const initialCallCount = mockInventoryService.getInventoryItems.mock.calls.length;

    await queryClient.invalidateQueries({ queryKey: ['inventory', 'dashboard'] });

    await waitFor(() => {
      expect(mockInventoryService.getInventoryItems.mock.calls.length).toBeGreaterThan(initialCallCount);
    });
  });

  it('should handle empty inventory gracefully', async () => {
    mockInventoryService.getInventoryItems.mockResolvedValue([]);
    mockInventoryService.getLowStockItems.mockResolvedValue([]);
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual({
      totalItems: 0,
      lowStockCount: 0,
      outOfStockCount: 0,
      totalValue: 0,
      recentMovements: [],
      alerts: []
    });
  });

  it('should set correct stale time', () => {
    renderHook(() => useInventoryDashboard(), { wrapper });

    const queries = queryClient.getQueryCache().getAll();
    const dashboardQuery = queries.find(q => 
      JSON.stringify(q.queryKey).includes('dashboard')
    );

    expect(dashboardQuery?.options.staleTime).toBe(60 * 1000);
  });

  it('should handle partial service failures gracefully', async () => {
    mockInventoryService.getInventoryItems.mockResolvedValue([
      { id: '1', name: 'Item 1', currentStock: 100, unitPrice: 10 }
    ] as any);
    mockInventoryService.getLowStockItems.mockRejectedValue(new Error('Low stock fetch failed'));
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });
  });

  it('should calculate total value with decimal precision', async () => {
    const mockItems = [
      { id: '1', name: 'Item 1', currentStock: 10.5, unitPrice: 9.99 },
      { id: '2', name: 'Item 2', currentStock: 20.25, unitPrice: 15.50 }
    ];

    mockInventoryService.getInventoryItems.mockResolvedValue(mockItems as any);
    mockInventoryService.getLowStockItems.mockResolvedValue([]);
    mockInventoryService.getRecentMovements.mockResolvedValue([]);
    mockInventoryService.getAlerts.mockResolvedValue([]);

    const { result } = renderHook(() => useInventoryDashboard(), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    const expectedValue = (10.5 * 9.99) + (20.25 * 15.50);
    expect(result.current.data?.totalValue).toBeCloseTo(expectedValue, 2);
  });
});