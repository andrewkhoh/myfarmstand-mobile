import { renderHook, waitFor, act } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { 
  useBulkUpdateStock,
  useBulkCreateItems,
  useBulkDeleteItems,
  useBulkOperationProgress 
} from '../useBulkOperations';
import { InventoryService } from '../../../services/inventory/inventoryService';
import React from 'react';
import type { InventoryItem, StockUpdate } from '../../../types/inventory';

jest.mock('../../../services/inventory/inventoryService');
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    from: jest.fn(),
    auth: {
      getUser: jest.fn().mockResolvedValue({ data: { user: { id: 'test-user-id' } } })
    }
  }))
}));

describe('Bulk Operations Hooks', () => {
  let queryClient: QueryClient;
  let mockInventoryService: jest.Mocked<InventoryService>;

  const mockItems: Partial<InventoryItem>[] = [
    { id: '1', name: 'Item 1', currentStock: 100, unitPrice: 10 },
    { id: '2', name: 'Item 2', currentStock: 50, unitPrice: 20 },
    { id: '3', name: 'Item 3', currentStock: 75, unitPrice: 15 }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    jest.useRealTimers();
    
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false, gcTime: 0 },
        mutations: { retry: false }
      },
      logger: {
        log: () => {},
        warn: () => {},
        error: () => {}
      }
    });

    mockInventoryService = {
      getInventoryItems: jest.fn(),
      getInventoryItem: jest.fn(),
      getLowStockItems: jest.fn(),
      getRecentMovements: jest.fn(),
      getAlerts: jest.fn(),
      updateStock: jest.fn(),
      batchUpdateStock: jest.fn(),
      createInventoryItem: jest.fn(),
      deleteInventoryItem: jest.fn(),
      acknowledgeAlert: jest.fn(),
    } as any;

    (InventoryService as jest.MockedClass<typeof InventoryService>).mockImplementation(
      () => mockInventoryService
    );
  });

  afterEach(() => {
    queryClient.clear();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  describe('useBulkUpdateStock', () => {
    it('should update multiple items successfully', async () => {
      const updates: StockUpdate[] = [
        { id: '1', newStock: 150 },
        { id: '2', newStock: 75 },
        { id: '3', newStock: 100 }
      ];

      const mockResults = updates.map(update => ({
        success: true,
        data: { ...mockItems.find(i => i.id === update.id), currentStock: update.newStock }
      }));

      mockInventoryService.batchUpdateStock.mockResolvedValue(mockResults as any);

      const { result } = renderHook(() => useBulkUpdateStock(), { wrapper });

      await act(async () => {
        result.current.mutate(updates);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(mockInventoryService.batchUpdateStock).toHaveBeenCalledWith(updates);
      expect(result.current.data).toEqual(mockResults);
    });

    it('should handle partial failures', async () => {
      const updates: StockUpdate[] = [
        { id: '1', newStock: 150 },
        { id: '2', newStock: 75 }
      ];

      const mockResults = [
        { success: true, data: { id: '1', currentStock: 150 } },
        { success: false, error: new Error('Update failed for item 2') }
      ];

      mockInventoryService.batchUpdateStock.mockResolvedValue(mockResults as any);

      const { result } = renderHook(() => useBulkUpdateStock(), { wrapper });

      await act(async () => {
        result.current.mutate(updates);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockResults);
      expect(result.current.data?.filter(r => r.success)).toHaveLength(1);
      expect(result.current.data?.filter(r => !r.success)).toHaveLength(1);
    });

    it('should invalidate queries after bulk update', async () => {
      const updates: StockUpdate[] = [
        { id: '1', newStock: 150 },
        { id: '2', newStock: 75 }
      ];

      const mockResults = updates.map(update => ({
        success: true,
        data: { id: update.id, currentStock: update.newStock }
      }));

      mockInventoryService.batchUpdateStock.mockResolvedValue(mockResults as any);

      const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries');

      const { result } = renderHook(() => useBulkUpdateStock(), { wrapper });

      await act(async () => {
        result.current.mutate(updates);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      // Should invalidate detail queries for each successful update
      expect(invalidateSpy).toHaveBeenCalledWith({ 
        queryKey: ['inventory', 'detail', '1'] 
      });
      expect(invalidateSpy).toHaveBeenCalledWith({ 
        queryKey: ['inventory', 'detail', '2'] 
      });
      expect(invalidateSpy).toHaveBeenCalledWith({ 
        queryKey: ['inventory', 'list'] 
      });
    });

    it('should track progress during bulk update', async () => {
      const updates: StockUpdate[] = [
        { id: '1', newStock: 150 },
        { id: '2', newStock: 75 },
        { id: '3', newStock: 100 }
      ];

      let progressCallCount = 0;
      const onProgress = jest.fn(() => {
        progressCallCount++;
      });

      const mockResults = updates.map((update, index) => ({
        success: true,
        data: { id: update.id, currentStock: update.newStock }
      }));

      mockInventoryService.batchUpdateStock.mockImplementation(async (updates) => {
        // Simulate progress updates
        for (let i = 0; i < updates.length; i++) {
          onProgress({ completed: i + 1, total: updates.length });
        }
        return mockResults as any;
      });

      const { result } = renderHook(() => useBulkUpdateStock(onProgress), { wrapper });

      await act(async () => {
        result.current.mutate(updates);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(onProgress).toHaveBeenCalledTimes(3);
      expect(onProgress).toHaveBeenCalledWith({ completed: 3, total: 3 });
    });
  });

  describe('useBulkCreateItems', () => {
    it('should create multiple items successfully', async () => {
      const newItems = [
        { name: 'New Item 1', sku: 'NI001', currentStock: 100, unitPrice: 10 },
        { name: 'New Item 2', sku: 'NI002', currentStock: 50, unitPrice: 20 }
      ];

      const createdItems = newItems.map((item, index) => ({
        ...item,
        id: `new-${index + 1}`,
        createdAt: new Date(),
        updatedAt: new Date()
      }));

      // Mock individual creates
      createdItems.forEach(item => {
        mockInventoryService.createInventoryItem.mockResolvedValueOnce(item as any);
      });

      const { result } = renderHook(() => useBulkCreateItems(), { wrapper });

      await act(async () => {
        result.current.mutate(newItems as any);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(mockInventoryService.createInventoryItem).toHaveBeenCalledTimes(2);
      expect(result.current.data).toHaveLength(2);
      expect(result.current.data?.every(r => r.success)).toBe(true);
    });

    it('should handle creation failures gracefully', async () => {
      const newItems = [
        { name: 'New Item 1', sku: 'NI001', currentStock: 100, unitPrice: 10 },
        { name: 'New Item 2', sku: 'NI002', currentStock: 50, unitPrice: 20 }
      ];

      // First succeeds, second fails
      mockInventoryService.createInventoryItem
        .mockResolvedValueOnce({ id: 'new-1', ...newItems[0] } as any)
        .mockRejectedValueOnce(new Error('Creation failed'));

      const { result } = renderHook(() => useBulkCreateItems(), { wrapper });

      await act(async () => {
        result.current.mutate(newItems as any);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toHaveLength(2);
      expect(result.current.data?.[0].success).toBe(true);
      expect(result.current.data?.[1].success).toBe(false);
    });

    it('should invalidate lists after bulk creation', async () => {
      const newItems = [
        { name: 'New Item 1', sku: 'NI001', currentStock: 100, unitPrice: 10 }
      ];

      mockInventoryService.createInventoryItem.mockResolvedValue({ 
        id: 'new-1', 
        ...newItems[0] 
      } as any);

      const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries');

      const { result } = renderHook(() => useBulkCreateItems(), { wrapper });

      await act(async () => {
        result.current.mutate(newItems as any);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(invalidateSpy).toHaveBeenCalledWith({ 
        queryKey: ['inventory', 'list'] 
      });
      expect(invalidateSpy).toHaveBeenCalledWith({ 
        queryKey: ['inventory', 'dashboard'] 
      });
    });
  });

  describe('useBulkDeleteItems', () => {
    it('should delete multiple items successfully', async () => {
      const itemIds = ['1', '2', '3'];

      mockInventoryService.deleteInventoryItem.mockResolvedValue(undefined);

      const { result } = renderHook(() => useBulkDeleteItems(), { wrapper });

      await act(async () => {
        result.current.mutate(itemIds);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(mockInventoryService.deleteInventoryItem).toHaveBeenCalledTimes(3);
      itemIds.forEach(id => {
        expect(mockInventoryService.deleteInventoryItem).toHaveBeenCalledWith(id);
      });
    });

    it('should handle deletion failures', async () => {
      const itemIds = ['1', '2'];

      mockInventoryService.deleteInventoryItem
        .mockResolvedValueOnce(undefined)
        .mockRejectedValueOnce(new Error('Deletion failed'));

      const { result } = renderHook(() => useBulkDeleteItems(), { wrapper });

      await act(async () => {
        result.current.mutate(itemIds);
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toHaveLength(2);
      expect(result.current.data?.[0].success).toBe(true);
      expect(result.current.data?.[1].success).toBe(false);
    });

    it('should optimistically remove items from cache', async () => {
      // Set initial data in cache
      queryClient.setQueryData(['inventory', 'list'], mockItems);

      const itemIds = ['1', '2'];
      mockInventoryService.deleteInventoryItem.mockResolvedValue(undefined);

      const { result } = renderHook(() => useBulkDeleteItems(), { wrapper });

      await act(async () => {
        result.current.mutate(itemIds);
      });

      // Check optimistic update
      const cached = queryClient.getQueryData(['inventory', 'list']) as any[];
      expect(cached).toHaveLength(1);
      expect(cached[0].id).toBe('3');
    });
  });

  describe('useBulkOperationProgress', () => {
    it('should track operation progress', async () => {
      const { result } = renderHook(() => useBulkOperationProgress(), { wrapper });

      expect(result.current.progress).toBeNull();
      expect(result.current.isOperationInProgress).toBe(false);

      act(() => {
        result.current.startOperation(10);
      });

      expect(result.current.progress).toEqual({ completed: 0, total: 10 });
      expect(result.current.isOperationInProgress).toBe(true);

      act(() => {
        result.current.updateProgress(5);
      });

      expect(result.current.progress).toEqual({ completed: 5, total: 10 });

      act(() => {
        result.current.completeOperation();
      });

      expect(result.current.progress).toBeNull();
      expect(result.current.isOperationInProgress).toBe(false);
    });

    it('should calculate percentage correctly', async () => {
      const { result } = renderHook(() => useBulkOperationProgress(), { wrapper });

      act(() => {
        result.current.startOperation(4);
      });

      expect(result.current.percentage).toBe(0);

      act(() => {
        result.current.updateProgress(1);
      });

      expect(result.current.percentage).toBe(25);

      act(() => {
        result.current.updateProgress(2);
      });

      expect(result.current.percentage).toBe(50);

      act(() => {
        result.current.updateProgress(4);
      });

      expect(result.current.percentage).toBe(100);
    });
  });
});