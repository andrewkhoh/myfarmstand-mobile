// Phase 4: Business Intelligence Schemas Implementation (GREEN Phase)
// Following docs/architectural-patterns-and-best-practices.md
// Pattern: Database-first validation + transformation schemas + TypeScript return annotations

import { z } from 'zod';

// Business Intelligence Constants
export const INSIGHT_TYPES = ['correlation', 'trend', 'anomaly', 'recommendation'] as const;
export const IMPACT_LEVELS = ['low', 'medium', 'high', 'critical'] as const;
export const AFFECTED_AREAS = ['inventory', 'marketing', 'sales', 'operational', 'strategic'] as const;

// Phase 1: Database-First Validation
// Raw database schema validation - must match database structure exactly
export const BusinessIntelligenceDatabaseSchema = z.object({
  id: z.string(),
  insight_type: z.enum(INSIGHT_TYPES),
  insight_title: z.string().min(1, 'Insight title cannot be empty').max(500, 'Insight title too long'),
  insight_description: z.string().min(1, 'Insight description cannot be empty'),
  confidence_score: z.number()
    .min(0, 'Confidence score cannot be negative')
    .max(1, 'Confidence score cannot exceed 1.0')
    .nullable(),
  impact_level: z.enum(IMPACT_LEVELS),
  affected_areas: z.array(z.string()).min(1, 'At least one affected area required'),
  supporting_data: z.record(z.any()).nullable(), // JSONB field
  recommendation_actions: z.array(z.string()).default([]),
  insight_date_range: z.string().regex(
    /^\[.*\)$/,
    'Invalid date range format (must be PostgreSQL daterange)'
  ),
  generated_by: z.string().min(1, 'Generated by field cannot be empty').default('system'),
  is_active: z.boolean().nullable().default(true),
  created_at: z.string().datetime().nullable().optional(),
  updated_at: z.string().datetime().nullable().optional()
}).strict().refine(
  (data) => {
    // Business rule: supporting_data must be valid JSON object when present
    if (data.supporting_data !== null) {
      try {
        // Ensure it's a proper object (not array or primitive)
        return typeof data.supporting_data === 'object' && !Array.isArray(data.supporting_data);
      } catch {
        return false;
      }
    }
    return true;
  },
  {
    message: 'Supporting data must be a valid JSON object',
    path: ['supporting_data']
  }
).refine(
  (data) => {
    // Business rule: affected_areas must contain valid area types
    return data.affected_areas.every(area => 
      AFFECTED_AREAS.includes(area as any) || 
      area.startsWith('custom_') // Allow custom area types
    );
  },
  {
    message: 'All affected areas must be valid area types',
    path: ['affected_areas']
  }
).refine(
  (data) => {
    // Business rule: high/critical insights should have confidence score
    if (['high', 'critical'].includes(data.impact_level) && data.confidence_score === null) {
      return false;
    }
    return true;
  },
  {
    message: 'High and critical impact insights require confidence score',
    path: ['confidence_score']
  }
).refine(
  (data) => {
    // Business rule: recommendation insights should have actions
    if (data.insight_type === 'recommendation' && data.recommendation_actions.length === 0) {
      return false;
    }
    return true;
  },
  {
    message: 'Recommendation insights must include recommendation actions',
    path: ['recommendation_actions']
  }
);

// Phase 2: Transformation Interface (explicit definition to avoid circular references)
// Following Phase 1, 2, 3 architectural pattern
export interface BusinessIntelligenceTransform {
  id: string;
  insightType: typeof INSIGHT_TYPES[number];
  insightTitle: string;
  insightDescription: string;
  confidenceScore: number | null;
  impactLevel: typeof IMPACT_LEVELS[number];
  affectedAreas: string[];
  supportingData: Record<string, any> | null;
  recommendationActions: string[];
  insightDateRange: string;
  generatedBy: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

// Phase 2: Transformation Schema (snake_case → camelCase)
// Following architectural pattern: transformation with null-safe defaults
export const BusinessIntelligenceTransformSchema = BusinessIntelligenceDatabaseSchema.transform((data): BusinessIntelligenceTransform => {
  return {
    id: data.id,
    insightType: data.insight_type,                                   // Snake → camel
    insightTitle: data.insight_title,                                 // Snake → camel
    insightDescription: data.insight_description,                     // Snake → camel
    confidenceScore: data.confidence_score,                           // Snake → camel, preserve null
    impactLevel: data.impact_level,                                   // Snake → camel
    affectedAreas: data.affected_areas,                               // Snake → camel
    supportingData: data.supporting_data,                             // Snake → camel, preserve null
    recommendationActions: data.recommendation_actions,               // Snake → camel
    insightDateRange: data.insight_date_range,                        // Snake → camel
    generatedBy: data.generated_by,                                   // Snake → camel
    isActive: data.is_active ?? true,                                 // Snake → camel, with null fallback only
    createdAt: data.created_at || new Date().toISOString(),          // Snake → camel, with default
    updatedAt: data.updated_at || new Date().toISOString()           // Snake → camel, with default
  };
});

// Phase 3: Creation Schema
// For creating new business intelligence insights (excludes generated/managed fields)
export const CreateBusinessIntelligenceSchema = z.object({
  insight_type: z.enum(INSIGHT_TYPES),
  insight_title: z.string().min(1, 'Insight title required').max(500, 'Insight title too long'),
  insight_description: z.string().min(1, 'Insight description required'),
  confidence_score: z.number()
    .min(0, 'Confidence score cannot be negative')
    .max(1, 'Confidence score cannot exceed 1.0')
    .nullable()
    .optional(),
  impact_level: z.enum(IMPACT_LEVELS),
  affected_areas: z.array(z.string()).min(1, 'At least one affected area required'),
  supporting_data: z.record(z.any()).nullable().optional(),
  recommendation_actions: z.array(z.string()).default([]).optional(),
  insight_date_range: z.string().regex(
    /^\[.*\)$/,
    'Invalid date range format (must be PostgreSQL daterange)'
  ),
  generated_by: z.string().min(1, 'Generated by field required').default('system').optional(),
  is_active: z.boolean().default(true).optional()
}).strict().refine(
  (data) => {
    // Same validation rules as database schema
    if (['high', 'critical'].includes(data.impact_level) && !data.confidence_score) {
      return false;
    }
    return true;
  },
  {
    message: 'High and critical impact insights require confidence score',
    path: ['confidence_score']
  }
).refine(
  (data) => {
    if (data.insight_type === 'recommendation' && (!data.recommendation_actions || data.recommendation_actions.length === 0)) {
      return false;
    }
    return true;
  },
  {
    message: 'Recommendation insights must include recommendation actions',
    path: ['recommendation_actions']
  }
);

// Phase 4: Update Schema
// For updating existing business intelligence insights (all fields optional except validation constraints)
export const UpdateBusinessIntelligenceSchema = z.object({
  insight_type: z.enum(INSIGHT_TYPES).optional(),
  insight_title: z.string().min(1, 'Insight title cannot be empty').max(500, 'Insight title too long').optional(),
  insight_description: z.string().min(1, 'Insight description cannot be empty').optional(),
  confidence_score: z.number()
    .min(0, 'Confidence score cannot be negative')
    .max(1, 'Confidence score cannot exceed 1.0')
    .nullable()
    .optional(),
  impact_level: z.enum(IMPACT_LEVELS).optional(),
  affected_areas: z.array(z.string()).min(1, 'At least one affected area required').optional(),
  supporting_data: z.record(z.any()).nullable().optional(),
  recommendation_actions: z.array(z.string()).optional(),
  insight_date_range: z.string().regex(
    /^\[.*\)$/,
    'Invalid date range format (must be PostgreSQL daterange)'
  ).optional(),
  generated_by: z.string().min(1, 'Generated by field cannot be empty').optional(),
  is_active: z.boolean().optional()
}).strict().refine(
  (data) => {
    // Same validation rules as database schema, but only when fields are present
    if (data.impact_level && ['high', 'critical'].includes(data.impact_level) && data.confidence_score === null) {
      return false;
    }
    return true;
  },
  {
    message: 'High and critical impact insights require confidence score',
    path: ['confidence_score']
  }
).refine(
  (data) => {
    if (data.insight_type === 'recommendation' && data.recommendation_actions && data.recommendation_actions.length === 0) {
      return false;
    }
    return true;
  },
  {
    message: 'Recommendation insights must include recommendation actions',
    path: ['recommendation_actions']
  }
);

// Type Exports
export type BusinessIntelligenceDatabaseContract = z.infer<typeof BusinessIntelligenceDatabaseSchema>;
export type CreateBusinessIntelligenceContract = z.infer<typeof CreateBusinessIntelligenceSchema>;
export type UpdateBusinessIntelligenceContract = z.infer<typeof UpdateBusinessIntelligenceSchema>;

// Constants Export
export const BUSINESS_INTELLIGENCE_CONSTANTS = {
  INSIGHT_TYPES,
  IMPACT_LEVELS,
  AFFECTED_AREAS,
  MIN_CONFIDENCE_SCORE: 0,
  MAX_CONFIDENCE_SCORE: 1,
  HIGH_IMPACT_CONFIDENCE_THRESHOLD: 0.7,
  CRITICAL_IMPACT_CONFIDENCE_THRESHOLD: 0.8
} as const;